<?php

namespace battleoase\battlecore\npcSystem\entities;

use battleoase\battlecore\npcSystem\classes\AssignableTag;
use battleoase\battlecore\npcSystem\classes\CustomType;
use battleoase\battlecore\npcSystem\handler\NPCEventHandler;
use battleoase\battlecore\npcSystem\handler\preset\CommandExecutionHandler;
use battleoase\battlecore\npcSystem\handler\preset\MessageHandler;
use battleoase\battlecore\npcSystem\handler\preset\TeleportPlayerHandler;
use battleoase\battlecore\npcSystem\handler\preset\TitleHandler;
use pocketmine\entity\Human;
use pocketmine\entity\Location;
use pocketmine\entity\Skin;
use pocketmine\math\Vector3;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\nbt\tag\ListTag;
use pocketmine\world\ChunkLoader;
use pocketmine\world\format\Chunk;
use pocketmine\world\World;

class CustomNPC extends Human implements ChunkLoader
{

	/** this is the type of the entity
	 * @var CustomType
	 */
	private $type = null;

	/**
	 * @var string
	 * this is the origin entity title
	 */
	private $header = "";

	/**
	 * this is a list of tags given that are currently being applied to the entity
	 * @var AssignableTag[]
	 */
	private $tags = [];


	/**
	 * @var NPCEventHandler
	 */
	private $handler = null;

	public function __construct(Location $location, Skin $skin, ?CompoundTag $nbt = null, bool $test)
	{
		$level = $location->getWorld();
		$x = $location->getX();
		$z = $location->getZ();
		if ($level->isChunkLoaded($x >> 4, $z >> 4) === false) {
			$level->loadChunk($x >> 4, $z >> 4);
		}
		$level->registerChunkLoader($this, $x >> 4, $z >> 4, true);
		$this->skin = $skin;
        $this->setNameTagVisible(true);
        $this->setNameTagAlwaysVisible(true);
        $this->setHasGravity(false);
        if($test) {
            if ($nbt->getTag("handler") !== "" or !$nbt->getTag("handler")) {
                if (!is_null($nbt->getTag("valueHandler"))) {
                    switch ($nbt->getString("handler")) {
                        case "command":
                            $command = new CommandExecutionHandler();
                            $command->setCommand($nbt->getString("valueHandler"));
                            $this->handler = $command;
                            break;
                        case "message":
                            $command = new MessageHandler();
                            $command->setMessage($nbt->getString("valueHandler"));
                            $this->handler = $command;
                            break;
                        case "title":
                            $command = new TitleHandler();
                            $command->setTitle($nbt->getString("valueHandler"));
                            $this->handler = $command;
                            break;

                    }
                }
            }
            if(!is_null($nbt->getTag("size"))) {
                $this->scale = $nbt->getInt("size");
            }
        }
		parent::__construct($location,$skin, $nbt);
	}

	public function update()
	{
		$iterate = $this->header;
		foreach ($this->tags as $tag) {
			$iterate .= "\n";
			$iterate .= $tag->getDisplayLayout();
		}
		$this->setNameTag($iterate);
	}


	/*ublic static function createBaseNBT(Vector3 $pos, ?Vector3 $motion = null, float $yaw = 0.0, float $pitch = 0.0): CompoundTag
	{
		return parent::createBaseNBT($pos, $motion, $yaw, $pitch); // TODO: Change the autogenerated stub
	}*/

	/**
	 * @return bool
	 */
	public function hasHandler(): bool
	{
		return $this->handler instanceof NPCEventHandler;
	}

	/**
	 * @return NPCEventHandler|null
	 */
	public function getHandler(): ?NPCEventHandler
	{
		return $this->handler;
	}

	public function addTag(AssignableTag $tag)
	{
		$this->tags[$tag->getName()] = $tag;
	}

	public function hasTag(AssignableTag $tag)
	{
		return array_key_exists($tag->getName(), $this->tags);
	}

	public function removeTag(AssignableTag $tag)
	{
		if ($this->hasTag($tag)) {
			unset($this->tags[$tag->getName()]);
		}
	}

	/**
	 * @return CustomType
	 */
	public function getType(): CustomType
	{
		return $this->type;
	}

	/**
	 * @param CustomType $type
	 */
	public function setType(CustomType $type): void
	{
		$this->type = $type;
	}


	public function getHeader(): string
	{
		return $this->header;
	}


	/**
	 * @param string $header
	 */
	public function setHeader(string $header): void
	{
		$this->header = $header;
	}

	/**
	 * @param NPCEventHandler $handler
	 */
	public function setHandler(?NPCEventHandler $handler): void
	{
		$this->handler = $handler;
		$this->saveNBT();
	}

    public function saveNBT() : CompoundTag{
        $nbt = parent::saveNBT();
        $nbt->setString("handler", ($this->handler == null) ? "" : $this->getHandler()->getName());

        if(($this->handler == null) ? "" : $this->getHandler()->getName() !== "") {
            if($this->handler instanceof CommandExecutionHandler) {
                $nbt->setString("valueHandler", $this->handler->getCommand());
            } elseif($this->handler instanceof MessageHandler) {
                $nbt->setString("valueHandler", $this->handler->getMessage());
            } elseif($this->handler instanceof TitleHandler) {
                $nbt->setString("valueHandler", $this->handler->getTitle());
            } else {
                $nbt->setString("valueHandler", "");
            }

        }
        $nbt->setInt("size", $this->getScale());
        return $nbt;
    }
 ###################################### Chunk Population ######################################
	public function isLoaderActive(): bool{return ($this->isAlive() && !($this->isClosed()));}
	public function onChunkPopulated(Chunk $chunk){}
	public function getLoaderId(): int{return spl_object_id($this);}
	public function onBlockChanged(Vector3 $block){}
	public function onChunkChanged(Chunk $chunk){}
	public function onChunkLoaded(Chunk $chunk){}
	public function onChunkUnloaded(Chunk $chunk){}

}